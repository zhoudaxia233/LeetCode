# 解题思路：
>[题目链接](https://leetcode.com/problems/rotate-array/description/)

先获取数组的后k个元素，再获取数组去掉了后k个元素的部分，再把这两个部分拼接起来。  
重点是要做到in-place，也就是要操作那个内存地址里的东西，而不能创建一个新的返回。  

---
关于Python的解法：  
首先，in-place修改数组怎么做呢？请看如下代码：
```
a = b #1

a[:] = b #2

```
其中，第一行代码就没有做到in-place，它只是改变了a的指针指向。而第二行代码做到了in-place，它把a这个地址的内容替换成了b的，也可以说，a相当于b的一个**浅拷贝**。

其次，如何获取后k个元素，以及如何获取剩余的部分，(对我来说)不是很简单，容易出些小错误。
>e.g.假设数组是a，我们要获取 去掉了后k个元素的数组：  
方法1：采用负数索引，得到`a[:-k]`。  
方法2：采用正数索引，得到`a[:len(a)-k]`

>其中，方法1就是容易出错的，或者说，it is error-prone。因为当k为0时，负号不起作用了，此时`a[:-k]`将会返回空数组。然而实际上，如果k为0，说明我们不想去掉任何元素，返回的东西应该是原数组。而正数索引就不会出现这种问题。所以，尽量少用负数索引！！！

>如何理解负数索引？  
`a[:-k]`：从第零个元素开始，到倒数第k个为止。由于Python的区间是左闭右开的，因此倒数第k个元素不会被包含在内。

>如何理解正数索引？  
`a[:len(a)-k]`：一共`len(a)`这么多元素，去掉`k`个，还剩下`len(a)-k`个。由于Python的区间是左闭右开的，[0, len(a)-k)这个区间包含的恰好就是`len(a)-k`个元素。