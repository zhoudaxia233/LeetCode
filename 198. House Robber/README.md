# 解题思路：
>[题目链接](https://leetcode.com/problems/house-robber/description/)

这道题一看就是动态规划的典型问题，那么，怎么看出来的呢？  
1. 问题具有最优子结构：  
当前状态的最优解可以由前面的某个或某些状态的最优解直接得到。也就是说，当前获得的最大抢劫收益可以通过前面步骤的最大抢劫收益来得到。
1. 问题具有无后效性：  
如果前面状态的最优解的求法并不影响当前的最优解的求法，也就是说，我不关心你前面的最优解是通过怎样的计算方法得到的，我只关心你得到的最优解的值是什么，那么这就叫做无后效性。
>如果你还想对动态规划问题有进一步深入的理解，我推荐你点击这个链接：[点我点我！](https://www.zhihu.com/question/23995189/answer/35429905)

近一步分析，当前的最大抢劫收益只可能来自两种情况，要么就是抢了当前房子，要么就是不抢当前房子。
>假设劫匪现在正在第`i`个房子里面，并且在犹豫要不要抢。  

>我们将劫匪进入第`i`个房子时的最大抢劫收益记为`f(i)`。  

**假设我们抢了当前房子**，由于题目中的限制，我们不能抢两个连着的房子，因此，**在抢了当前房子这个假设的前提下**，当前最大抢劫收益等于劫匪在当前房子的抢劫收益加上劫匪进入上上个房子时的最大抢劫收益，即`f(i) = nums[i] + f(i-2)`。
> 其中，`nums[i]`表示第`i`个房子中放的钱的数量。

**假设我们没抢当前房子**，则当前最大抢劫收益等于劫匪进入上一个房子时的最大抢劫收益，即`f(i) = f(i-1)`。  

我们只需要选择二者中较大的值即可。即：  
`f(i) = max(f(i-1), nums[i] + f(i-2))`

---
关于Python的解法：  
动态规划还有一个特点，就是“建表”和“查表”。因此我们先建立一个`maximum`数组，用来存储劫匪进入每一个房间后，当前累计获得的最大抢劫收益。(e.g. `maximum[i]`对应存储的是劫匪在进入第`i`个房子后，累计获得的最大抢劫收益。)
