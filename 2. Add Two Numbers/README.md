# 解题思路：
>[题目链接](https://leetcode.com/problems/add-two-numbers/description/)

基本思路就是同时遍历两个链表，然后把对应的值加起来，同时记录一下进位。值得注意的是边界条件的判断。此题可分为两种情况，“当两个链表长度**不相同**时”以及“当两个链表长度**相同**时”。  

当长度不相同时，就会出现一个链表当前位置结点已经为空，而另一个链表中对应的当前位置的结点尚不为空。此种情况下我们有两种处理办法：  
其一是把空结点当作结点值为0的结点来处理，这样就把特殊情况做了一般化处理，便于写代码；  
其二是遇到空结点的时候，就把另一条链表剩下的非空结点部分直接原样“接”在要返回的链表后面(就像接了一条尾巴)。这样做的话，在实际写代码过程中会遇到一些麻烦：首先，我们要记录一下被返回链表的当前指针的前一个指针，因为我们在遍历过程中，不断地进行`curr = curr.next`操作，当我们需要把多出来的那部分直接“接”在要返回的`curr`链表时，我们不能直接写`curr = l_rest`，这样`curr`的值就被覆盖了。我们只能写`curr.next = l_rest`，但如果这样的话，我们其实就跳过了一个当前结点`curr`(我们想把`l_rest`“接”在`curr`的后面，而不是`curr.next`的后面)。为此，我们需要维护一个额外的局部变量来保存前一个遍历过程的指针指向。此外，当我们“接”完了这个尾巴以后，还需要判断一下当前的进位，如果有进位的话，还需要加在这个尾巴上做进一步计算。   

最后，当我们处理完两个链表按位相加之后(也就是对两个链表都遍历完成之后)，还要看一下最终结果是否有进位，如果有进位，我们需要在返回链表的后面再添加一个结点(其值为1)。

---
关于Python的解法：  
由于我选择了返回一个新链表，而非在已有链表之上进行修改，同时，链表的创建过程也是在遍历中进行的(对应到代码里，也就是在循环中进行的)，因此我创建结点的时候就**不能**写`l = ListNode(0)`，而只能写`l.next = ListNode(0)`，否则我永远只能得到一个单节点的链表。也正是因此，我们在返回的时候要返回的是`next`指针中的内容(这是一个很常用的trick)。