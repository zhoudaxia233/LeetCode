# 解题思路：
>[题目链接](https://leetcode.com/problems/valid-parentheses/description/)

这道题比较简单，用**栈**来解决最合适不过。解释如下：
>`{([])}`，对于这个括号序列，我们可以观察到，最外层的`{`和`}`是一对儿，最内层的`[`和`]`也是一对儿，中间的`(`和`)`也是一对儿。  
最外层的`{`是最开始的第一个元素，而最外层的`}`是最后一个元素。第一个元素和最后一个元素匹配，第二个元素和倒数第二个元素匹配，这不正是**栈**这个数据结构“先进后出”的特点吗？

---
关于Python的解法：  
首先要考虑的问题就是如何表示三组不同的左括号和右括号的对应关系，我使用了Python中的字典结构：  
`{'(': ')', '{': '}', '[': ']'}`。  
其次，这道题还要重点注意边界条件判断。假设输入序列只有左括号，或者只有右括号的情况，我们都要考虑进去：  

**只有左括号**的情况：  
我判断了一下`stack`这个只装着左括号的变量，如果循环结束后，`stack`依然不为空，就说明我们并没有在序列中找到匹配的右括号，因此返回`False`，在代码中的体现就是`return len(stack) == 0`。  
  
**只有右括号**的情况：  
我判断了一下`stack`这个只装着左括号的变量是否为空，如果`stack`为空说明根本没有左括号，此时返回`False`，只有当左括号存在的情况下，我们才继续进行进一步的判断，也就是判断括号是否正确匹配。在代码中的体现就是`if len(stack) == 0 or i != match[stack.pop()]`。
