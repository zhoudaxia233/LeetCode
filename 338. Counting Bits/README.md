# 解题思路：
>[题目链接](https://leetcode.com/problems/counting-bits/)

最开始的思路比较简单粗暴，就是遍历从`0`到`num`的所有数字，然后把每个数字都转换成二进制，再计算一下其中有多少个`1`，然后将结果存放在一个列表里。代码如下：
```python
class Solution:
    def countBits(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        res = []
        for i in range(num + 1):
            i_b = bin(i)
            res.append(i_b.count('1'))
        return res

```
但是题目中有三个要求，
1. 要求时间复杂度为`O(n)`而非`O(n*sizeof(integer))`。
2. 空间复杂度为`O(n)`。
3. 不要用编程语言的内置函数来计算`1`的个数。

针对这三个要求，我们开始思考如何改进我们的代码。首先，我们一开始的思路，在每轮循环中，对每个数字的处理是独立的，我们相当于孤立了每个数字，而忽略了数字之间的关联。**那么如何利用这种关联呢？**我们可以试着，看能否把问题拆分成更小规模的子问题来解决。我们可以试着写下从零开始的几个数字的二进制来观察一下规律，稍加观察我们可以发现：

> ...  
> num_of_ones(011010) = num_of_ones(01101) + 0
> num_of_ones(01101) = num_of_ones(0110) + 1
> num_of_ones(0110) = num_of_ones(011) + 0  
> ...  
> 规律：某个数字的二进制形式中`1`的个数 = 把该数字的二进制形式中最后一位“**砍掉**”后的`1`的个数 + 被“**砍掉**”的部分的值(`1`或`0`)

>我们之所以要**砍掉**一位，是为了利用前面计算好了的结果。通过这种方式，我们把一个大的问题的求解，划分成了一个子问题的求解。这就是动态规划中的“**最优子结构**”。

---
